canvasCreate = document.createElement('canvas');

document.getElementById('l-wrapper_canvas').insertBefore(canvasCreate, document.getElementById('resetButton'));
document.getElementsByTagName('canvas')[0].id = 'heatmap';
canvas = document.getElementById('heatmap');
context = canvas.getContext('2d');


//todo:Стили canvas
canvas.width = 300;
canvas.height = 300;

canvas.className = 'clear';
canvas.style.border = '1px solid';

points = {};
SCALE  = 1;
x      = -1;
y      = -1;

function loadDemo() {
    document.getElementById('resetButton').addEventListener('click', reset);
    context.globalAlpha = 0.2; //Прозрачность отрисовываемая для всех операций, при наслоении будут видны предыдущие
    context.globalCompositeOperation = 'lighter'; //Определяем как будет вести себя цветопередачи при наслоении операций
    function sample() {
        if (x !== -1) { //Если мышь находится в пределах холста
            addToPoint(x, y);
            //Обрабатывать движения внутри холста
            canvas.onmousemove = function (e) {
                x = e.clientX - e.target.offsetLeft; //Текущее положение мыши по оси х минус растояние от левого края экрана до холста = растояние машы внутри холста по оси х от левого края
                y = e.clientY - e.target.offsetTop;
                addToPoint(x, y);//запускать при каждом движении
            };
        } else {
            canvas.onmousemove = function(e) {x = e.clientX;};
        }
        setTimeout(sample, 100);//Если мышь вне холста, проверять не появилась ли она каждые 100 милисекунд
    }
    sample();
}
//Очищение холста
function reset() {
    points = {};
    context.clearRect(0, 0, 300, 300);
    y = -1;
}
//Подборка цвета
function getColor(intensity) {//Интенсити это радиус, который на самом деле точка значение нагревания :)
    var colors = ['#072933', '#2E4045', '#8C593B', '#B2814E', '#FAC268', '#FAD237', 'null', 'null', 'null', '#F00'];
    return colors[Math.floor(intensity / 2)]; //floor округляет в меньшую сторону(в пол), 18.97 / 2 и округл в меньшую сторону = 9
}
//Отрисовка кругов под мышкой
function drawPoint(x, y, radius) {
    radius = Math.sqrt(radius)*6; //Math.sqrt - квадратный корень, макс число которое может прийти 10 квадратный корень = 3.16 * 6 и из этого квадратный корень = 18.97, используется для определения цвета и ширины круга.
    context.beginPath();
    context.fillStyle = getColor(radius); //закрашиваем цветом полученным из getColor
    context.arc(x, y, radius, 0, Math.PI*2); //x,y получаем из canvas.onmousemove это кординаты место нахождения курсора, 3 аргумент - радиус, показатель нагрева точки, со временем увеличивается и начинает менять свой цвет, за счет этого начиная от середины цвет начинает меняться, 0 - начало поворота, 2ПИ(это ровно целый круг) конец поворота, true - против часовой стрелки
    context.closePath();//попробовать без этого
    context.fill();//закрашиваем круг
}

//Подсчет интенсивности точки и сохранение значения
function addToPoint(x, y) {
    x = Math.floor(x/SCALE); //SCALE задан 3 в самом начале, зачем?, перезаписываем полученные кординаты, чем больше SCALE тем меньше координата + округление в меньшую сторону, смысл в убыстрении нагревания, за счет повторного использования точек кординат при движении мыши, по сути инкремент применяется для всех близлижащих точек как для одной, в результате страдает точность записи пути.
    y = Math.floor(y/SCALE);
    if(points[[x, y]] === undefined) {points[[x, y]] = 1;}//Если мышь зашла на хост и попала на кординаты которые ранее не были посещенны им присвается значение 1, по умолчанию они undefined
    else if (points[[x, y]] === 10) {return;}//Если точка наколилась до 10 выбрасывать из синтаксической конструкции
    else {points[[x, y]]++;} //Наколять поступающие точки
    drawPoint(x*SCALE, y*SCALE, points[[x, y]]);
}

addEventListener('load', loadDemo);//Помимо мелочей запускает слежку за canvas

//1. Ставится обработчик событий который запуска передачу координат мыши - это функция sample(), внутри функции loadDemo, которая запускается после загрузки страницы. Внутри фукции sample реализованна рекурсия, поэтому после первого запуска каждые 100 миллисекунд она будет проверять не изменилось ли значение х (это кординаты мыши внутри холста по оси х), значение координат мыши, когда она находится за пределами холста -1, любое захождение на холст его изменит и будет вызвана функция addToPoint и в нее переданы аргументами текущие координаты мыши
//2. addToPoint - основные задачи функции: нагревание точки и вызов функции отрисовки точки с информацией о нагретости. SCALE увеличивает скорость нагревания точки за счет использования меньшего объема координат(он думает что мышь находится все по тем же координатам хотя она сместилась дальше и продолжает нагревать) за счет этого увеличивается шаг отрисовки и уменьшается точность, если курсор первый раз попал на какие-либо координаты, то им присваивается значение 1, если точка нагрелась до значения 10 - нагревание прекращается, в конце значения координат нормальзуются и вместе со значение нагретости передаются в функцию drawPoint.
//3. drawPoint - основные задачи функции: отрисовка круга и вызов функции выбора цвета с передачей ей необходимого значения.
//4. getColor - выбор цвета
